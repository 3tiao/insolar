// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: insolar/record/record.proto

package record

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_pkg_errors "github.com/pkg/errors"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GenesisRecord X_GenesisRecord
type ChildRecord X_ChildRecord
type JetRecord X_JetRecord
type RequestRecord X_RequestRecord
type ResultRecord X_ResultRecord
type TypeRecord X_TypeRecord
type CodeRecord X_CodeRecord
type ObjectActivateRecord X_ObjectActivateRecord
type ObjectAmendRecord X_ObjectAmendRecord
type ObjectDeactivateRecord X_ObjectDeactivateRecord

// Returns pointer to any sub-record type or error
func UnmarshalRecord(data []byte) (Record, error) {
	base := X_Record{}

	if error := base.Unmarshal(data); error != nil {
		return nil, github_com_pkg_errors.Wrap(error, "Failed to unmarshal request")
	}

	union := base.GetUnion()

	if union == nil {
		return nil, github_com_pkg_errors.New("We go empty request")
	}

	var subRecord Record

	switch union.(type) {
	case *X_Record_Genesis:
		subRecord = (*GenesisRecord)(((union).(*X_Record_Genesis).Genesis))
	case *X_Record_Child:
		subRecord = (*ChildRecord)(((union).(*X_Record_Child).Child))
	case *X_Record_Jet:
		subRecord = (*JetRecord)(((union).(*X_Record_Jet).Jet))
	case *X_Record_Request:
		subRecord = (*RequestRecord)(((union).(*X_Record_Request).Request))
	case *X_Record_Result:
		subRecord = (*ResultRecord)(((union).(*X_Record_Result).Result))
	case *X_Record_Type:
		subRecord = (*TypeRecord)(((union).(*X_Record_Type).Type))
	case *X_Record_Code:
		subRecord = (*CodeRecord)(((union).(*X_Record_Code).Code))
	case *X_Record_ObjectActivate:
		subRecord = (*ObjectActivateRecord)(((union).(*X_Record_ObjectActivate).ObjectActivate))
	case *X_Record_ObjectAmend:
		subRecord = (*ObjectAmendRecord)(((union).(*X_Record_ObjectAmend).ObjectAmend))
	case *X_Record_ObjectDeactivate:
		subRecord = (*ObjectDeactivateRecord)(((union).(*X_Record_ObjectDeactivate).ObjectDeactivate))
	default:
		return nil, fmt.Errorf("__Record.union has unexpected type %T", subRecord)
	}
	return subRecord, nil
}

// Puts sub-record into record and convert it to binary (if any)
func MarshalRecord(subRecord Record) ([]byte, error) {
	base := X_Record{}

	switch subRecord.(type) {
	case *GenesisRecord:
		base.Union = &X_Record_Genesis{(*X_GenesisRecord)(subRecord.(*GenesisRecord))}
	case *ChildRecord:
		base.Union = &X_Record_Child{(*X_ChildRecord)(subRecord.(*ChildRecord))}
	case *JetRecord:
		base.Union = &X_Record_Jet{(*X_JetRecord)(subRecord.(*JetRecord))}
	case *RequestRecord:
		base.Union = &X_Record_Request{(*X_RequestRecord)(subRecord.(*RequestRecord))}
	case *ResultRecord:
		base.Union = &X_Record_Result{(*X_ResultRecord)(subRecord.(*ResultRecord))}
	case *TypeRecord:
		base.Union = &X_Record_Type{(*X_TypeRecord)(subRecord.(*TypeRecord))}
	case *CodeRecord:
		base.Union = &X_Record_Code{(*X_CodeRecord)(subRecord.(*CodeRecord))}
	case *ObjectActivateRecord:
		base.Union = &X_Record_ObjectActivate{(*X_ObjectActivateRecord)(subRecord.(*ObjectActivateRecord))}
	case *ObjectAmendRecord:
		base.Union = &X_Record_ObjectAmend{(*X_ObjectAmendRecord)(subRecord.(*ObjectAmendRecord))}
	case *ObjectDeactivateRecord:
		base.Union = &X_Record_ObjectDeactivate{(*X_ObjectDeactivateRecord)(subRecord.(*ObjectDeactivateRecord))}
	default:
		return nil, fmt.Errorf("__Record.union has unexpected type %T", subRecord)
	}
	return base.Marshal()
}
