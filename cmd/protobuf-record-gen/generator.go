//
// Copyright 2019 Insolar Technologies GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package main

import (
	"strings"

	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
)

const (
	BaseRecordName = "__Record"
	BaseOneOfName  = "union"
	InternalPrefix = "__"
	RecordSuffix   = "Record"
)

// Generator is the type whose methods generate the output, stored in the associated response structure.
type RecordPluginGenerator struct {
	*generator.Generator
	generator.PluginImports
}

// Name identifies the plugin.
func (p *RecordPluginGenerator) Name() string {
	return "RecordPlugin"
}

// Init is called once after data structures are built but before
// code generation begins.
func (p *RecordPluginGenerator) Init(g *generator.Generator) {
	p.Generator = g
}

func prefixType(inp string) string {
	if strings.HasPrefix(inp, "_") {
		return "X" + inp[1:]
	}
	return inp
}

func (p *RecordPluginGenerator) generateIsolation(msg *descriptor.DescriptorProto) {
	for _, field := range msg.GetField() {
		oldType := prefixType(InternalPrefix + field.GetName() + RecordSuffix)
		newType := field.GetName() + RecordSuffix
		p.P(`type `, newType, ` `, oldType, `;`)
	}
	p.P()
}

func (p *RecordPluginGenerator) generateMarshal(msg *descriptor.DescriptorProto) {
	errorsPkg := p.NewImport("github.com/pkg/errors")

	// Unmarshal function
	p.P(`// Returns pointer to any sub-record type or error`)
	p.P(`func UnmarshalRecord(data []byte) (Record, error) {`)
	p.P(`  base := `, prefixType(BaseRecordName), `{}`)
	p.P()
	p.P(`  if error := base.Unmarshal(data); error != nil {`)
	p.P(`    return nil, `, errorsPkg.Use(), `.Wrap(error, "Failed to unmarshal request")`)
	p.P(`  }`)
	p.P()
	p.P(`  union := base.GetUnion()`)
	p.P()
	p.P(`  if union == nil {`)
	p.P(`    return nil, `, errorsPkg.Use(), `.New("We go empty request")`)
	p.P(`  }`)
	p.P()
	p.P(`  var subRecord Record`)
	p.P()
	p.P(`  switch union.(type) {`)
	for _, field := range msg.GetField() {
		uniType := prefixType(BaseRecordName + "_" + field.GetName())
		newType := field.GetName() + RecordSuffix

		p.P(`  case *`, uniType, `:`)
		p.P(`    subRecord = (*`, newType, `)(((union).(*`, uniType, `).`, field.GetName(), `))`)
	}
	p.P(`  default:`)
	p.P(`    return nil, fmt.Errorf("`, BaseRecordName, `.`, BaseOneOfName, ` has unexpected type %T", subRecord)`)
	p.P(`  }`)
	p.P(`  return subRecord, nil`)
	p.P(`}`)

	p.P()
}

func (p *RecordPluginGenerator) generateUnmarshal(msg *descriptor.DescriptorProto) {
	// Marshal function
	p.P(`// Puts sub-record into record and convert it to binary (if any)`)
	p.P(`func MarshalRecord(subRecord Record) ([]byte, error) {`)
	p.P(`  base := `, prefixType(BaseRecordName), `{}`)
	p.P()
	p.P(`  switch subRecord.(type) {`)
	for _, field := range msg.GetField() {
		uniType := prefixType(BaseRecordName + "_" + field.GetName())
		oldType := prefixType(InternalPrefix + field.GetName() + RecordSuffix)
		newType := field.GetName() + RecordSuffix

		p.P(`  case *`, field.GetName(), RecordSuffix, `:`)
		p.P(`    base.Union = &`, uniType, `{ (*`, oldType, `)(subRecord.(*`, newType, `)) }`)
	}
	p.P(`  default:`)
	p.P(`    return nil, fmt.Errorf("`, BaseRecordName, `.`, BaseOneOfName, ` has unexpected type %T", subRecord)`)
	p.P(`  }`)
	p.P(`  return base.Marshal()`)
	p.P(`}`)
}

// Generate produces the code generated by the plugin for this file,
// except for the imports, by calling the generator's methods P, In, and Out.
func (p *RecordPluginGenerator) Generate(file *generator.FileDescriptor) {
	p.PluginImports = generator.NewPluginImports(p.Generator)

	msg := file.GetMessage(BaseRecordName)
	if msg == nil {
		return
	}

	oneOfList := msg.GetOneofDecl()
	if len(oneOfList) != 1 {
		return
	} else if oneOfList[0].Name == nil || *oneOfList[0].Name != BaseOneOfName {
		return
	} else {
		p.generateIsolation(msg)
		p.P()
		p.generateMarshal(msg)
		p.P()
		p.generateUnmarshal(msg)
	}
}

// GenerateImports produces the import declarations for this file.
// It is called after Generate.
func (p RecordPluginGenerator) GenerateImport(file *generator.FileDescriptor) {
}
